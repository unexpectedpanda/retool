from __future__ import annotations

import re
from re import Pattern
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from modules.dats import DatNode
    from modules.config import Config
    from modules.titletools import Removes

from modules.title_selection.overrides_post_filters import user_override_post_filter_match
from modules.titletools import TitleTools, TraceTools
from modules.utils import eprint


def excludes(
    processed_titles: dict[str, set[DatNode]], config: Config, removes: Removes
) -> dict[str, set[DatNode]]:
    """
    Works through a dict of DatNodes and removes nodes that match user criteria.

    Args:
        processed_titles (dict[str, set[DatNode]]): A work in progress dictionary
        of DatNodes, originally populated from the input DAT and actively being worked
        on by Retool.

        config (Config): The Retool config object.

        removes (Removes): The Retool removes object, which contains and categorizes
        all the titles that have been removed from consideration. Is used for stats
        and other output files generated by Retool.

    Returns:
        `dict[str, set[DatNode]]` A dictionary of DatNodes with titles excluded
        based on user criteria.
    """
    eprint('• Applying category and user excludes... ')

    # Set up title tracking
    report_on_match: bool = False

    if config.user_input.trace:
        for titles in processed_titles.values():
            report_on_match = TraceTools.trace_enable(set(titles), config.user_input.trace)

            if report_on_match:
                break

    if report_on_match:
        eprint('Stage: Exclusions', level='heading')

    exclude_categories: set[tuple[str, str]] = set()
    exclude_titles_regex: set[tuple[Pattern[str], str, str]] = set()

    if config.user_input.no_add_ons:
        exclude_categories.add(('Add-Ons', 'addons_count'))
    if config.user_input.no_aftermarket:
        exclude_titles_regex.add((config.regex.aftermarket, 'aftermarket_count', 'Aftermarket'))
    if config.user_input.no_applications:
        exclude_categories.add(('Applications', 'applications_count'))
        exclude_titles_regex.add((config.regex.programs, 'applications_count', 'Applications'))
    if config.user_input.no_audio:
        exclude_categories.add(('Audio', 'audio_count'))
    if config.user_input.no_bad_dumps:
        exclude_titles_regex.add((config.regex.bad, 'bad_dumps_count', 'Bad Dumps'))
    if config.user_input.no_bios:
        exclude_categories.add(('BIOS', 'bios_count'))
        exclude_categories.add(('Console', 'bios_count'))
        exclude_titles_regex.add((config.regex.bios, 'bios_count', 'BIOS'))
    if config.user_input.no_bonus_discs:
        exclude_categories.add(('Bonus Discs', 'bonus_discs_count'))
    if config.user_input.no_coverdiscs:
        exclude_categories.add(('Coverdiscs', 'coverdiscs_count'))
    if config.user_input.no_demos:
        exclude_categories.add(('Demos', 'demos_count'))
        for demo in config.regex.demos:
            exclude_titles_regex.add((demo, 'demos_count', 'Demos'))
    if config.user_input.no_educational:
        exclude_categories.add(('Educational', 'educational_count'))
    if config.user_input.no_games:
        exclude_categories.add(('Games', 'games_count'))
    if config.user_input.no_manuals:
        exclude_categories.add(('Manuals', 'manuals_count'))
        exclude_titles_regex.add((config.regex.manuals, 'manuals_count', 'Manuals'))
    if config.user_input.no_multimedia:
        exclude_categories.add(('Multimedia', 'multimedia_count'))
        exclude_titles_regex.add((config.regex.multimedia, 'multimedia_count', 'Multimedia'))
    if config.user_input.no_pirate:
        exclude_categories.add(('Pirate', 'pirate_count'))
        exclude_titles_regex.add((config.regex.pirate, 'pirate_count', 'Pirate'))
    if config.user_input.no_preproduction:
        exclude_categories.add(('Preproduction', 'preproduction_count'))
        for preproduction in config.regex.preproduction:
            exclude_titles_regex.add((preproduction, 'preproduction_count', 'Preproduction'))
    if config.user_input.no_promotional:
        exclude_categories.add(('Promotional', 'promotional_count'))
        exclude_titles_regex.add((config.regex.promotional, 'promotional_count', 'Promotional'))
    if config.user_input.no_unlicensed:
        exclude_categories.add(('Unlicensed', 'unlicensed_count'))
        exclude_titles_regex.add((config.regex.unlicensed, 'unlicensed_count', 'Unlicensed'))
    if config.user_input.no_video:
        exclude_categories.add(('Video', 'video_count'))
        for video in config.regex.video:
            exclude_titles_regex.add((video, 'video_count', 'Video'))

    temp_dict = processed_titles.copy()
    exclude_titles: set[DatNode] = set()
    exclude_related: set[DatNode] = set()
    count: int = 0

    for titles in temp_dict.values():
        if config.user_input.trace:
            report_on_match = TraceTools.trace_enable(set(titles), config.user_input.trace)

        for title in titles:
            # Category excludes
            category: str
            category_remove_name: str
            category_removes: set[DatNode]
            title_found: bool = False

            for exclude_category in [x for x in exclude_categories if x[0] in title.categories]:
                if report_on_match:
                    TraceTools.trace_title(
                        'REF0042', [', '.join(title.categories)], {title}, keep_remove=False
                    )

                if title not in exclude_titles and title.group_name in processed_titles:
                    # Superset titles can be in multiple groups, so deduping needs to be done
                    # for exclude stats
                    if not any(d.full_name == title.full_name for d in exclude_titles):
                        count = getattr(config.stats, exclude_category[1])
                        count += 1
                        setattr(config.stats, exclude_category[1], count)

                        exclude_titles.add(title)

                        category = exclude_category[0]

                        if category == 'Console':
                            category = 'BIOS'

                        title.exclude_reason = f'Category exclude, {category}'

                        category_remove_name = f'{category.lower()}_removes'.replace(
                            ' ', '_'
                        ).replace('-', '_')

                        category_removes = getattr(removes, category_remove_name)
                        category_removes.add(title)
                        title_found = True

                        setattr(removes, category_remove_name, category_removes)

            if title_found:
                continue

            # Regex excludes
            for exclude_regex in [
                x for x in exclude_titles_regex if re.search(x[0], title.full_name)
            ]:
                if report_on_match:
                    TraceTools.trace_title(
                        'REF0044',
                        [
                            str(exclude_regex[0])
                            .replace('re.compile(', '')
                            .replace(', re.IGNORECASE)', '')
                        ],
                        {title},
                        keep_remove=False,
                    )

                if title not in exclude_titles and title.group_name in processed_titles:
                    # Superset titles can be in multiple groups, so deduping needs to be done
                    # for exclude stats
                    if not any(d.full_name == title.full_name for d in exclude_titles):
                        count = getattr(config.stats, exclude_regex[1])
                        count += 1
                        setattr(config.stats, exclude_regex[1], count)

                        exclude_titles.add(title)

                        title.exclude_reason = f'Category exclude, {exclude_regex[2]}'

                        category = exclude_regex[2]
                        category_remove_name = f'{category.lower()}_removes'.replace(
                            ' ', '_'
                        ).replace('-', '_')

                        category_removes = getattr(removes, category_remove_name)
                        category_removes.add(title)
                        title_found = True

                        setattr(removes, category_remove_name, category_removes)

            if title_found:
                continue

            # MIA excludes
            if config.user_input.no_mia:
                if title.is_mia:
                    # Superset titles can be in multiple groups, so deduping needs to be done
                    # for exclude stats
                    if not any(d.full_name == title.full_name for d in exclude_titles):
                        count = config.stats.mia_count
                        count += 1
                        setattr(config.stats, 'mia_count', count)

                        if report_on_match:
                            TraceTools.trace_title('REF0062', [], {title}, keep_remove=False)

                        exclude_titles.add(title)
                        title.exclude_reason = 'Known MIA title'
                        removes.mia_removes.add(title)
                        title_found = True

                        if report_on_match:
                            TraceTools.trace_title(
                                'REF0044',
                                [
                                    str(exclude_regex[0])
                                    .replace('re.compile(', '')
                                    .replace(', re.IGNORECASE)', '')
                                ],
                                {title},
                                keep_remove=False,
                            )

            if title_found:
                continue

            # Custom overrides excludes
            if not config.user_input.no_overrides:
                if config.system_exclude:
                    if user_override_post_filter_match(
                        title, config.system_exclude
                    ) and not user_override_post_filter_match(title, config.system_include):
                        if report_on_match:
                            TraceTools.trace_title('REF0045', [], {title}, keep_remove=False)

                        if title not in exclude_titles and title.group_name in processed_titles:
                            # Superset titles can be in multiple groups, so deduping needs to be done
                            # for exclude stats
                            if not any(d.full_name == title.full_name for d in exclude_titles):
                                config.stats.system_exclude_count += 1

                                exclude_titles.add(title)

                                title.exclude_reason = 'User system exclude'
                                removes.system_excludes.add(title)
                    elif user_override_post_filter_match(
                        title, config.system_exclude
                    ) and user_override_post_filter_match(title, config.system_include):
                        if report_on_match:
                            TraceTools.trace_title('REF0050', [], {title}, keep_remove=False)

                if config.global_exclude:
                    if (
                        user_override_post_filter_match(title, config.global_exclude)
                        and not user_override_post_filter_match(title, config.global_include)
                        and not user_override_post_filter_match(title, config.system_include)
                    ):
                        if report_on_match:
                            TraceTools.trace_title('REF0046', [], {title}, keep_remove=False)

                        if title not in exclude_titles and title.group_name in processed_titles:
                            # Superset titles can be in multiple groups, so deduping needs to be done
                            # for exclude stats
                            if not any(d.full_name == title.full_name for d in exclude_titles):
                                config.stats.global_exclude_count += 1

                                exclude_titles.add(title)

                                title.exclude_reason = 'User global exclude'
                                removes.global_excludes.add(title)
                    elif user_override_post_filter_match(
                        title, config.global_exclude
                    ) and user_override_post_filter_match(title, config.global_include):
                        if report_on_match:
                            TraceTools.trace_title('REF0051', [], {title}, keep_remove=False)
                    elif user_override_post_filter_match(
                        title, config.global_exclude
                    ) and user_override_post_filter_match(title, config.system_include):
                        if report_on_match:
                            TraceTools.trace_title('REF0052', [], {title}, keep_remove=False)

    if not config.user_input.no_overrides:
        # Find related exclusions based on overrides
        for title in exclude_titles:
            if title.exclude_include_related:
                for related_title in processed_titles[title.group_name]:
                    if not (
                        any(d.full_name == related_title.full_name for d in exclude_titles)
                        or any(d.full_name == related_title.full_name for d in exclude_related)
                    ):
                        if title.exclude_reason == 'User system exclude':
                            config.stats.system_exclude_count += 1

                            related_title.exclude_reason = 'Related to user system excludes'
                            removes.system_excludes.add(related_title)
                        elif title.exclude_reason == 'User global exclude':
                            config.stats.global_exclude_count += 1

                            related_title.exclude_reason = 'Related to user global excludes'

                            removes.global_excludes.add(related_title)

                        exclude_related.add(related_title)

    exclude_titles = exclude_titles | exclude_related

    # Remove excluded titles
    remove_titles: set[DatNode] = set()
    found_titles: set[DatNode] = set()

    for exclude_title in exclude_titles:
        found_titles = TitleTools.find_title(
            exclude_title.full_name, 'full', temp_dict, set(), config, deep_search=True
        )

        for found_title in found_titles:
            if found_title.group_name in processed_titles:
                for title in processed_titles[found_title.group_name]:
                    if exclude_title.full_name == title.full_name:
                        remove_titles.add(title)

    for title in remove_titles:
        processed_titles[title.group_name].remove(title)

    # Clean up empty groups
    for group_name in temp_dict.keys():
        if not processed_titles[group_name]:
            del processed_titles[group_name]

    eprint('• Applying category and user excludes... done.', overwrite=True)

    return processed_titles
